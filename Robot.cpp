// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Robot.h"
#include "Commands/AutonomousCommandGroup.h"
#include "Commands/LedTurnOff.h"
#include "Commands/SetCameraForTeleop.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
Drivetrain* Robot::drivetrain = 0;
Trunnion* Robot::trunnion = 0;
Shooter* Robot::shooter = 0;
Claw* Robot::claw = 0;
Vision* Robot::vision = 0;
Lights* Robot::lights = 0;
CompressorSubsystem* Robot::compressorSubsystem = 0;
OI* Robot::oi = 0;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
FILE *Robot::logFile = NULL;
void Robot::Log(string message) {
	if(logFile == NULL) {
		logFile = fopen("log.txt", "a");
	}
	fprintf(logFile, "%s\n", message.c_str());
}
void Robot::RobotInit() {
	RobotMap::init();
	prefs = Preferences::GetInstance();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	drivetrain = new Drivetrain();
	trunnion = new Trunnion();
	shooter = new Shooter();
	claw = new Claw();
	vision = new Vision();
	lights = new Lights();
	compressorSubsystem = new CompressorSubsystem();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	lw = LiveWindow::GetInstance();
	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand = new AutonomousCommand();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
//	autonomousCommand = new AutonomousCommandGroup(3);
	chooser = new SendableChooser();
	chooser->AddDefault("1 Shot", new AutonomousCommandGroup(1));
	chooser->AddObject("Do Nothing", new AutonomousCommandGroup(0));
	chooser->AddObject("2 Shot", new AutonomousCommandGroup(2));
	chooser->AddObject("Only Drive", new AutonomousCommandGroup(3));
	chooser->AddObject("2 Shot Vision Track", new AutonomousCommandGroup(4));
		
	SmartDashboard::PutData("Autonomous Command", chooser);
  }
void Robot::AutonomousInit() {
//	prefs->PutInt("Autonomous");
//	int auton = prefs->GetInt("Autonomous");
//	SmartDashboard::PutNumber("Auton", prefs->GetInt("Autonomous"));
//	autonomousCommand = new AutonomousCommandGroup(prefs->GetInt("Autonomous", 4));
	autonomousCommand = (Command*) (chooser->GetSelected());
//	SmartDashboard::PutNumber("Auton", auton);
	if (autonomousCommand != NULL)
		autonomousCommand->Start();
}
void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}
void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to 
	// continue until interrupted by another command, remove
	// this line or comment it out.
	autonomousCommand->Cancel();
	(new LedTurnOff())->Start();
//	(new SetCameraForTeleop())->Start();
//	ledCommand->Start();
	SmartDashboard::PutNumber("TEST VARIABLE", prefs->GetFloat("Test", 0.0));
}
void Robot::TeleopPeriodic() {
	if (autonomousCommand != NULL) {
		Scheduler::GetInstance()->Run();
	}
	SmartDashboard::PutNumber("ArmAngle", Robot::trunnion->GetAngle());
//	SmartDashboard::PutBoolean("ArmWheel", Robot::claw->GetWheel());
//	SmartDashboard::PutNumber("X Axis", -1 * Robot::oi->getStick1()->GetRawAxis(2));
//	SmartDashboard::PutNumber("Y Axis", Robot::oi->getStick1()->GetRawAxis(4));
//	SmartDashboard::PutBoolean("Cocked", Robot::shooter->GetCocked());
//	SmartDashboard::PutNumber("LeftDrive", Robot::drivetrain->left->Get());
//	SmartDashboard::PutNumber("RightDrive", Robot::drivetrain->right->Get());
//	SmartDashboard::PutNumber("Encoder Average", Robot::drivetrain->GetDistance());
//	SmartDashboard::PutNumber("Encoder left", Robot::drivetrain->leftEncoder->Get());
//	SmartDashboard::PutNumber("Encoder right", Robot::drivetrain->rightEncoder->Get());
//	SmartDashboard::PutNumber("Encoder left raw", Robot::drivetrain->leftEncoder->GetRaw());
//	SmartDashboard::PutNumber("Encoder right raw", Robot::drivetrain->rightEncoder->GetRaw());
	SmartDashboard::PutBoolean("VisionTracking", Robot::vision->GetGoalState());
//	SmartDashboard::PutBoolean("BallInClaw", Robot::lights->HasBall());
//	SmartDashboard::PutNumber("LEDNumber", Robot::lights->clawLeds->Get());
	SmartDashboard::PutBoolean("EnoughPressure", Robot::compressorSubsystem->Pressurized());
//	SmartDashboard::PutBoolean("Loaded", Robot::shooter->loaded);
//	SmartDashboard::PutNumber("TEST VARIABLE", prefs->GetFloat("Test", 0.0));
	SmartDashboard::PutNumber("GYROSCOPE", Robot::drivetrain->GetDirection());
	SmartDashboard::PutBoolean("Limit Switch", Robot::shooter->eye->Get());
	SmartDashboard::PutNumber("RawVoltage", Robot::trunnion->armAngle->GetVoltage());
}
void Robot::TestPeriodic() {
	lw->Run();
}
START_ROBOT_CLASS(Robot);
